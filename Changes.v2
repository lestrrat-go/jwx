Changes
=======

[Incompatible Changes]
  These are changes that are incompatible with the v1.x.x version.

  # tl;dr for JWT users:

    // most basic
    jwt.Parse(serialized, jwt.WithKey(alg, key))
    jwt.Sign(token, jwt.WithKey(alg,key))

    // with a jwk.Set
    jwt.Parse(serialized, jwt.WithKeySet(set))

    // UseDefault/InferAlgorithm with JWKS
    jwt.Parse(serialized, jwt.WithKeySet(set,
      jws.WithUseDefault(true), jws.WithInferAlgorithm(true))

    // Use `jku`
    jwt.Parse(serialized, jwt.WithVerifyAuto(...))

    // Any other custom key provisioning (using functions in this
    // example, but can be anything that fulfills jws.KeyProvider)
    jwt.Parse(serialized, jwt.WithKeyProvider(jws.KeyProviderFunc(...)))

  # tl;dr for JWK users:

    // jwk.New() was confusing. Renamed to fit the actual implementation
    key, err := jwk.FromRaw(rawKey)

  # Module

  * Module now requires go 1.17

  * Use of github.com/pkg/errors is no more. If you were relying on bevaior
    that depends on the errors being an instance of github.com/pkg/errors
    then you need to change your code

  * File-generation tools have been moved out of internal/ directories.
    These files pre-dates Go modules, and they were in internal/ in order
    to avoid being listed in the `go doc` -- however, now that we can
    make them separate modules this is no longer necessary.

  # JWE

  * [jwe] `jwe.Compact()`'s signature has changed to 
    `jwe.Compact(*jwe.Message, ...jwe.CompactOption)`

  * [jwe] `jwe.JSON()` has been removed. You can generate JSON serialization
    using `jwe.Encrypt(jwe.WitJSON())` or `json.Marshal(jwe.Message)`

  * [jwe] `(jwe.Message).Decrypt()` has been removed. Since formatting of the
    original serialized message matters (including whitespace), using a parsed
    object was inherently confusing.

  * [jwe] `jwe.Encrypt()` can now generate JWE messages in either compact or JSON
    forms. By default, the compact form is used. JSON format can be
    enabled by using the `jwe.WithJSON` option.

  * [jwe] `jwe.Encrypt()` can now accept multiple keys by passing multiple
    `jwe.WithKey()` options. This can be used with `jwe.WithJSON` to
    create JWE messages with multiple recipients.

  * [jwe] `jwe.DecryptEncryptOption()` has been renamed to `jwe.EncryptDecryptOption()`.
    This is so that it is more uniform with `jws` equivalent of `jws.SignVerifyOption()`
    where the producer (`Sign`) comes before the consumer (`Verify`) in the naming

  * [jwe] `jwe.WithCompact` and `jwe.WithJSON` options have been added
    to control the serialization format.

  * [jwe] jwe.Decrypt()'s method signature has been changed to

      jwt.Decrypt([]byte, ...jwe.DecryptOption) ([]byte, error)

    - For static key pair, use `jwe.WithKey()`
    - For static JWKS, use `jwe.WithKeySet()` (NOTE: InferAlgorithmFromKey like in `jws` package is NOT supported)
    - For custom, possibly dynamic key provisioning, use `jwe.WithKeyProvider()`

    These options can be stacked. Therefore, you could configure the
    verification process to attempt a static key pair, a JWKS, and only
    try other forms if the first two fails, for example.

  * [jwe] jwe.Decrypter has been unexported. Users did not need this.
   
  * [jwe] jwe.WithKeyProvider() has been added to specify arbitrary
    code to specify which keys to try.

  * [jwe] jwe.KeyProvider interface has been added

  * [jwe] jwe.KeyProviderFunc has been added
 
  * [jwe] `WithPostParser()` has been removed. You can achieve the same effect
    by using `jwe.WithKeyProvider()`. Because this was the only consumer for
    `jwe.DecryptCtx`, this type has been removed as well.

  # JWK

  * [jwk] `jwk.New()` has been renamed to `jwk.FromRaw()`, which hopefully will
    make it easier for the users what the input should be.

  * [jwk] `jwk.NewRSAPRivateKey()`, `jwk.NewECDSAPrivateKey()`, etc have been removed.
    There is no longer any way to create concrete types of `jwk.Key` 

  * [jwk] `jwk.Key` type no longer supports direct unmarshaling via `json.Unmarshal()`,
    because you can no longer instantiate concrete `jwk.Key` types. You will need to
    use `jwk.ParseKey()`. See the documentation for ways to parse JWKs.

  * [jwk] `(jwk.Key).Algorithm()` is now of `jwk.KeyAlgorithm` type. This field used
    to be `string` and therefore could not be passed directly to `jwt.Sign()`
    `jws.Sign()`, `jwe.Encrypt()`, et al. This is no longer the case, and
    now you can pass it directly. See 
    https://github.com/lestrrat-go/jwx/blob/v2/docs/99-faq.md#why-is-jwkkeyalgorithm-and-jwakeyalgorithm-so-confusing
    for more details

  * [jwk] jwk.SetFetcher and jwk.SetFetchFunc has been added.
    They represent something that can fetch a jwk.Set

  # JWS

  * [jws] `jws.Sign()` can now generate JWS messages in either compact or JSON
    forms. By default, the compact form is used. JSON format can be
    enabled by using the `jws.WithJSON` option.

  * [jws] `jws.Sign()` can now accept multiple keys by passing multiple
    `jws.WithKey()` options. This can be used with `jws.WithJSON` to
    create JWS messages with multiple signatures.

  * [jws] `jws.WithCompact` and `jws.WithJSON` options have been added
    to control the serialization format.

  * [jws] jws.Verify()'s method signature has been changed to

      jwt.Verify([]byte, ...jws.VerifyOption) ([]byte, error)

    - For static key pair, use `jws.WithKey()`
    - For static JWKS, use `jws.WithKeySet()`
    - For enabling verification using `jku`, use `jws.WithVerifyAuto()`
    - For custom, possibly dynamic key provisioning, use `jws.WithKeyProvider()`

    These options can be stacked. Therefore, you could configure the
    verification process to attempt a static key pair, a JWKS, and only
    try other forms if the first two fails, for example.
   
  * [jws] jws.WithVerify() has been removed.

  * [jws] jws.WithKey() has been added to specify an algorithm + key to
    verify the payload with.

  * [jws] jws.WithKeySet() has been added to specify a JWKS to be used for
    verification. By default `kid` AND `alg` must match between the signature
    and the key.

    The option can take further suboptions:

      jws.Parse(serialized,
        jws.WithKeySet(set,
          // by default `kid` is required. set false to disable.
          jws.WithRequireKid(false),
          // optionally skip matching kid if there's exactly one key in set
          jws.WithUseDefault(true),
          // infer algorithm name from key type
          jws.WithInferAlgorithm(true),
        ),
      )

  * [jws] `jws.VerifuAuto` has been removed in favor of using
    `jws.WithVerifyAuto` option with `jws.Verify()`

  * [jws] `jws.WithVerifyAuto` has been added to enable verification
    using `jku`.

    The first argument must be a jwk.SetFetcher object, but can be
    set to `nil` to use the default implementation which is `jwk.Fetch`

    The rest of the arguments are treated as options passed to the
    `(jwk.SetFetcher).Fetch()` function.

  * [jws] jws.WithKeyProvider() has been added to specify arbitrary
    code to specify which keys to try.

  * [jws] jws.KeyProvider interface has been added

  * [jws] jws.KeyProviderFunc has been added
 
  * [jws] jws.WithKeyUsed has been added to allow users to retrieve
    the key used for verification. This is useful in cases you provided
    multiple keys and you want to know which one was successful

  # JWT

  * [jwt] `jwt.Parse` now verifies the signature and validates the token
    by default. You must disable it explicitly using `jwt.WithValidate(false)`
    and/or `jwt.WithVerify(false)` if you only want to parse the JWT message.

    If you don't want either, a convenience function `jwt.ParseInsecure`
    has been added.

  * [jwt] `jwt.Parse` can only parse raw JWT (JSON) or JWS (JSON or Compact).
    It no longer accepts JWE messages.

  * [jwt] `jwt.WithDecrypt` has been removed

  * [jwt] `jwt.WithJweHeaders` has been removed

  * [jwt] `jwt.WithVerify()` has been renamed to `jwt.WithKey()`. The option can
    be used for signing, encryption, and parsing.

  * [jwt] `jwt.UseDefault()` has been removed. You should use `jws.WithUseDefault()`
    as a suboption in the `jwt.WithKeySet()` option.

      jwt.Parse(serialized, jwt.WithKeySet(set, jws.WithUseDefault(true)))

  * [jwt] `jwt.InferAlgorithmFromKey()` has been removed. You should use
    `jws.WithInferAlgorithmFromKey()` as a suboption in the `jwt.WithKeySet()` option.

      jwt.Parse(serialized, jwt.WithKeySet(set, jws.WithInferAlgorithmFromKey(true)))

  * [jwt] jwt.WithKeySetProvider has been removed. The original purpose was to
    use the JWT data (such as `iss`) to figure out which key to use for
    verification. However, this can easily be implemented as follows:

      msg, _ := jws.Parse(serialized) // no verification
      token, _ := jwt.Parse(msg.Payload()) // no verification
      switch token.Issuer() {
      case jwt.IssuerKey:
        _, err := jws.Verify(serialized, jwt.WithKeySet(set))
        if err != nil {
          ...
        }
      }

    Also, this really... is not safe. You are using an unverified payload
    to verify the JWS.

  * [jws] Remove `jws.WithPayloadSigner()`. This should be completely repleceable
    using `jws.WithKey()`

  * [jwt] `jwt.Sign()` has been changed so that it works more like the new `jws.Sign()`

  * [jwt] `jwt.WithHeaders` and `jwt.WithJwsHeaders` have been removed.
    You should be able to use the new `jwt.WithKey` option to pass headers

  * [jwt] `jwt.WithSignOption` and `jwt.WithEncryptOption` have been added as
    escape hatches for options that are declared in `jws` and `jwe` packages
    but not in `jwt`
